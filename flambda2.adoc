:toc:
:toclevels: 5


# Sketch of Flambda 2.0 Semantics

This is an attempt of creating a minimal mathematical representation of Flambda 2.0. I tried to choose names that most accurately describe what the things are, if there's something wrong, I'll be happy to correct.

Purpose: resolve misunderstandings on my side about how Flambda 2.0 works. May serve as a draft for a formal semantics of Flambda 2.0, but will not be completed in every detail.

## Top-Level State
* _current_continuation_: ContinuationValue
* _heap_: Ref -> Value

## Smaller parts that make up the top-level state
* Simple _simple_ ::= _id_

* BoundVars _bound_vars_ ::=
** `Singleton` _var_in_binding_pos_ |
** `Set_of_closures` (_name_mode_, _closure_vars_)

* BoundSymbols _bound_symbols_ ::=
** `Singleton` _symbol_
** `Sets_of_closures` [_code_and_set_of_closures_]

* Named _named_ ::=
** `Simple` _simple_
** `Prim` _flambda_primitive_
** `Set_of_closures` _set_of_closures_

* ScopingRule _scoping_rule_ ::=
** `Syntactic` |
** `Dominator`

* StaticConst _static_const_ ::=
** `Block` _tag_ _mutable_or_immutable_ [_field_of_block_] |
** `Sets_of_closures` [_code_and_set_of_closures_]
** `Boxed_float` Numbers.Float_by_bit_pattern.t Or_variable.t
**  | Boxed_int32 of Int32.t Or_variable.t
**  | Boxed_int64 of Int64.t Or_variable.t
**  | Boxed_nativeint of Targetint.t Or_variable.t
**  | Immutable_float_array of Numbers.Float_by_bit_pattern.t Or_variable.t list
**  | Mutable_string of { initial_value : string; }
**  | Immutable_string of string

* Expression _e_ ::=
** `Let` _bound_vars_ `=` _named_ `in` _e_  |
** `Let_symbol (` _scoping_rule_ `)` _bound_symbols_ `=` _static_const_ `in` _e_ TODO |
** `Let_cont` TODO |
** `Apply` TODO |
** `Apply_cont` TODO |
** `Switch` TODO |
** `Invalid` TODO
* Ref
* Value
* Continuation
* ContinuationValue
** _env_: Environment
** _body_: Expression
* Environment =
** _continuations_ : Continuation -> ContinuationValue
** _return_cont_: Continuation
** _exn_cont_: Continuation


