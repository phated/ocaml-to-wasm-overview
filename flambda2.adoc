:toc:
:toclevels: 5


# Sketch of Flambda 2.0 Semantics

This is an attempt of creating a minimal, human-readable, mathematical representation of Flambda 2.0. I tried to choose names that most accurately describe what things are. Anything that is not absolutely required for the semantics is omitted. If there's something wrong, I'll be happy to correct.

Purpose: resolve misunderstandings on my side about how Flambda 2.0 works. May serve as a draft for a formal semantics of Flambda 2.0.

# State

## Top-Level State
* _current_continuation_: ContinuationValue
* _heap_: Ref -> Value

## Expressions

Expression _e_ ::=

* `Let` _bound_vars_ `=` _named_ `in` _e_  |
* `Let_symbol (` _scoping_rule_ `)` _bound_symbols_ `=` _static_const_ `in` _e_ |
* `Let_cont` _continuation_ `=` _let_cont_ `in` _e_  |
* `Apply` _call_kind_ _callee_ `(` _arg_* `)` _continuation_ _exn_continuation_ |
* `Apply_cont` _continuation_ `(` _arg_* `)` _trap_action_ |
* `Switch` _scrutinee_ _arms_ |
* `Invalid`

### `Let`

_bound_vars_ ::=

* `Singleton` _var_in_binding_pos_ |
* `Set_of_closures` (_name_mode_, _closure_vars_)

_named_ ::=

* `Simple` _simple_
* `Prim` _flambda_primitive_
* `Set_of_closures` _set_of_closures_

### `Let_symbol`

_scoping_rule_ ::= `Syntactic` | `Dominator`

_bound_symbols_ ::=

* `Singleton` _symbol_
* `Sets_of_closures` _code_and_set_of_closures_*

_static_const_ ::=

* `Block` _tag_ _mutable_or_immutable_ _field_of_block_* |
* `Sets_of_closures` _code_and_set_of_closures_* |
* `Boxed_float` [_B^64^_ | _variable_] |
* `Boxed_int32` [_B^32^_ | _variable_]  |
* `Boxed_int64` [_B^64^_ | _variable_]  |
* `Boxed_nativeint` [_targetint_ | _variable_]  |
* `Immutable_float_array` [_B^64^_ | _variable_]* |
* `Mutable_string` _string_ |
* `Immutable_string` _string_

### `Let_cont`

_continuation_ :== Z

_continuation_handler_ ::= _kinded_parameter_* _e_

_continuation_handlers_ : [`(` _continuation_ `,` _continuation_handler_ `)`]*

_let_cont_ ::=

* `Non_recursive` _continuation_handler_ |
* `Recursive` _continuation_handlers_

### `Apply`


_call_kind_ ::=

* `Function` _function_call_ |
* `Method` _method_kind_ `of` _simple |_
* `C_call` _alloc_ _param_arity_ _return_arity_

_alloc_ ::= B

_param_arity_ ::= _flambda_arity_

_return_arity_ ::= _flambda_arity_

_function_call_ ::=

* `Direct` _code_id_ _closure_id_ _return_arity_ |
* `Indirect_unknown_arity` |
* `Indirect_known_arity` _param_arity_ _return_arity_

_callee_ ::= _simple_

_exn_continuation_ ::=  _continuation_ [`(`_simple_ `,` _flambda_kind_`)`]*

### `Apply_cont`

_raise_kind_option_ ::=
* `None` |
* `Some Regular` |
* `Some Reraise` |
* `Some No_trace`

_trap_action_ ::=

* `Push` _continuation_ |
* `Pop` _continuation_ _raise_kind_option_

### `Switch`

_scrutinee_ ::= _simple_

_arms_ ::= `(` _target_imm_ `, Apply_cont` _continuation_ `(` _arg_* `)` _trap_action_ `)`

## TODO

_simple_ ::= _id_

* Ref
* Value
* Continuation
* ContinuationValue
** _env_: Environment
** _body_: Expression
* Environment =
** _continuations_ : Continuation -> ContinuationValue
** _return_cont_: Continuation
** _exn_cont_: Continuation


