:toc:
:toclevels: 5


# Sketch of Flambda 2.0 Semantics

This is an attempt of creating a minimal, human-readable, mathematical representation of Flambda 2.0. I tried to shorten things to the point that it's possible to get an impression what is going on at a quick glance. Anything that is not absolutely required for stating the semantics is omitted (i.e. all kinds of debug and optimization-relevant info are left out here).

Purpose: resolve misunderstandings and improve my understanding of how Flambda 2.0 works. May serve as a draft for a formal semantics or an interpreter of Flambda 2.0.

# AST

## Basic Definitions

### Identifier

_id_ is a name that is used to refer to something (Q: in the environment? Or somewhere else, too?).

### Simple

_simple_ ::= _id_

Q: what does simple as an identifier refer to? Does this refer to variables whose value is known to be "simple"? How is this different from _variable_?

### Variable

_variable_ ::= _id_

_variable_ is an identifier that refers to a variable in the environment. Q: Is this correct?

### Continuation

_continuation_ :== _id_

_continuation_ is an identifier that refers to a continuation handler in the environment.

### Kind

_flambda_kind_ ::= `Value` | `Naked_number` | `Fabricated`

_naked_number_kind_ ::= `Naked_immediate` | `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_standard_int_ ::= `Tagged_immediate` | `Naked_immediate` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_standard_int_or_float_ ::= `Tagged_immediate` | `Naked_immediate` | `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_boxable_number_ ::= `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint` | `Untagged_immediate`


## Expressions

Expression _e_ ::=

* `Let` _bound_vars_ `=` _named_ `in` _e_  |
* `Let_symbol (` _scoping_rule_ `)` _bound_symbols_ `=` _static_const_ `in` _e_ |
* `Let_cont` _continuation_ `=` _let_cont_ `in` _e_  |
* `Apply` _call_kind_ _callee_ `(` _arg_* `)` _continuation_ _exn_continuation_ |
* `Apply_cont` _continuation_ `(` _arg_* `)` _trap_action_ |
* `Switch` _scrutinee_ _arms_ |
* `Invalid`

### `Let`

_bound_vars_ ::=

* `Singleton` _var_in_binding_pos_ |
* `Set_of_closures` (_name_mode_, _closure_vars_)

_name_mode_ ::= `Normal` | `Phantom` | `In_types`

_var_in_binding_pos_ ::= _name_mode_ _variable_

_named_ ::=

* `Simple` _simple_
* `Prim` _flambda_primitive_
* `Set_of_closures` _set_of_closures_

### `Let_symbol`

_scoping_rule_ ::= `Syntactic` | `Dominator`

Q: does the scoping rule affect semantics, or can I omit this here?

_bound_symbols_ ::=

* `Singleton` _symbol_
* `Sets_of_closures (code_ids` _code_id_*, `closure_symbols` Map(_closure_id_ => _symbol_)`)`*

Q: Looking at https://github.com/ocaml-flambda/ocaml/blob/6ff563bcaa20d0e0ebecc689f9ed54baeba454b6/middle_end/flambda2.0/terms/let_symbol_expr.rec.ml#L22, I am confused: why is this a `Set` and not a list? How does this correspond to _code_and_set_of_closures_ below? I would expect that _bound_symbols_ defines essentially a list of symbols which are being bound, and that the value assigned to it is a list whose elements have both the function declaration _code_ (for which code is to be emitted), and the _set_of_closures_.
Q: why do we define set*s* of closures, instead of defining a single set of closures for every `Let_symbol` expression?

_static_const_ ::=

* `Block` _tag_ _mutable_or_immutable_ _field_of_block_* |
* `Sets_of_closures` _code_and_set_of_closures_* |
* `Boxed_float` [_B^64^_ | _variable_] |
* `Boxed_int32` [_B^32^_ | _variable_]  |
* `Boxed_int64` [_B^64^_ | _variable_]  |
* `Boxed_nativeint` [_targetint_ | _variable_]  |
* `Immutable_float_array` [_B^64^_ | _variable_]* |
* `Mutable_string` _string_ |
* `Immutable_string` _string_

_field_of_block_ ::=

* `Symbol` _symbol_ |
* `Tagged_immediate` _target_imm_ |
* `Dynamically_computed` _variable_


_code_and_set_of_closures_ ::= `(code ` Map(_code_id_ => _code_) `,` `set_of_closures` _set_of_closures_ `)`

_code_ ::= `(` _continuation_, _exn_continuation_, _kinded_parameter_*, _e_, _flambda_arity_ `)`

_set_of_closures_ ::= `(function_decls` _function_declarations_, `closure_elements` Map(_var_within_closure_ => _simple_) `)`

### `Let_cont`

_kinded_parameter_ ::= _variable_ : _flambda_kind_

_continuation_handler_ ::= `cont_handler` _kinded_parameter_* `.` _e_

_continuation_handlers_ : [_continuation_ `=>` _continuation_handler_]*

_let_cont_ ::=

* `Non_recursive` _continuation_handler_ |
* `Recursive` _continuation_handlers_

### `Apply`

_call_kind_ ::=

* `Function` _function_call_ |
* `Method` _method_kind_ `of` _simple |_
* `C_call` _alloc_ _param_arity_ _return_arity_

_method_kind_ ::= `Self` | `Public` | `Cached`

_alloc_ ::= B

_flambda_arity_ ::= _flambda_kind_*

_param_arity_ ::= _flambda_arity_

_return_arity_ ::= _flambda_arity_

_function_call_ ::=

* `Direct` _code_id_ _closure_id_ _return_arity_ |
* `Indirect_unknown_arity` |
* `Indirect_known_arity` _param_arity_ _return_arity_

_callee_ ::= _simple_

_exn_continuation_ ::= `exn_cont` _continuation_ `(` [_simple_ `=>` _flambda_kind_]* `)`

### `Apply_cont`

_raise_kind_option_ ::= `None` | `Some Regular` | `Some Reraise` | `Some No_trace`

_trap_action_ ::=

* `Push` _continuation_ |
* `Pop` _continuation_ _raise_kind_option_

### `Switch`

_scrutinee_ ::= _simple_

_arms_ ::= `(` _target_imm_ `, Apply_cont` _continuation_ `(` _arg_* `)` _trap_action_ `)`

_target_imm_ ::= _targetint_


# Compilation unit

_C_ = {

* _imported_symbols_ : Map(_symbol_ -> _flambda_kind_),
* _return_continuation_ : _continuation_,
* _exn_continuation_ : _continuation_,
* _body_ : _e_}

This is what the Flambda 2.0 unit looks like. I assume that this corresponds 1:1 to an `.ml` file.

I assume that _return_continuation_ and _exn_continuation_ act as placeholders for the continuations provided by whoever calls the initialization function.

The _body_ of the compilation unit is the Flambda 2.0 expression that corresponds to all OCaml code of the file. So, this _body_ will likely define some global symbols and assign values to them.

To initialize the compilation unit at runtime, the _body_ is run with an environment that contains all the necessary information about the symbols imported from other files. That means, in order to initialize a compilation unit, all the other compilation units that it depends on must be initialized beforehand.

# Program State

## Basic Definitions

### Reference

Ref is the set of abstract references to the heap. We do not care how exactly they look like. We assume the presence of a garbage collector that manages these references (whether this is one we implement, or one that the host environment will provide, we do not distinguish on, at this point).

### Function Reference

FuncRef is the set of abstract references to functions. The point of this is to have a way to call a function.

On x86 this specializes to: a pointer into linear memory, pointing to the location of the machine instructions emitted for the function.

On WASM, this specializes to: a `funcref` or an index into a global function table that refers to the WASM function emitted for the original function.

### (Heap) Value

Here is an attempt to describe what a heap value from the POV of Flambda 2.0 looks like, in the most general sense:

Value = {(x~1~, ..., x~n~) | x~i~ âˆˆ _heap_field_*}

_heap_field_ ::=

* `Targetint` _targetint_ |
* `FuncAddress` FuncRef |
* `Ref` Ref

I suppose that the target integers can or should be refined to all the different integer types of Flambda 2.0.

I don't know if this is sufficient to describe all the different heap blocks there are.

I have the suspicion, that it might make sense to make a more fine-grained model that takes into account the different kinds of tags that come with specific assumptions about the block. I'm holding off on that for now, though.

It seems that in Flambda 2.0, the closure representation does not contain the dreaded infix blocks anymore (which would have made the heap model more complex than this). Flambda has this nice representation of closures operationg `Project_var` and `Select_closure`. Maybe, if this turns out to be useful, this can be used to add a more abstract representation of closures here. Maybe not.

## Top-Level State

TODO

_env_: Environment =

* _global_symbols_: Map(_symbol_ => Value),
* _continuations_ : Map(_continuation_ => _continuation_handler_),
* _return_cont_: _continuation_,
* _exn_cont_: _continuation_,
* _current_body_ : Expression }

_heap_: Ref -> Value


TODO

# Semantics

## Initial State

Given a compilation unit _C_:

_env0_ (_C_) = {

* _global_symbols_ = {},
* _continuations_ = {},
* _return_cont_ = _C.return_continuation_,
* _exn_cont_ = _C.exn_continuation_,
* _body_ = _C.body_ }


## Step function

TODO
