:toc:
:toclevels: 5


# Sketch of Flambda 2.0 Semantics

This is an attempt of creating a minimal, human-readable, mathematical representation of Flambda 2.0. I tried to choose names that most accurately describe what things are. Anything that is not absolutely required for the semantics is omitted. If there's something wrong, I'll be happy to correct.

Purpose: resolve misunderstandings and improve my understanding of how Flambda 2.0 works. May serve as a draft for a formal semantics or an interpreter of Flambda 2.0.

Dear reader, if you see something wrong, or you see something that can be removed, let me know.

# AST

## Basic Definitions

### Identifier

_id_ is a name.

### Simple

_simple_ ::= _id_

QUESTION: what does simple as an identifier refer to? Does this refer to variables whose values are "simple"?

### Variable

_variable_ ::= _id_

_variable_ is an identifier that refers to a variable in the environment

### Continuation

_continuation_ :== _id_

_continuation_ is an identifier that refers to a continuation handler in the environment.

### Kind

_flambda_kind_ ::=

* `Value` |
* `Naked_number` |
* `Fabricated`

_naked_number_kind_ ::= `Naked_immediate` | `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_standard_int_ ::= `Tagged_immediate` | `Naked_immediate` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_standard_int_or_float_ ::= `Tagged_immediate` | `Naked_immediate` | `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_boxable_number_ ::= `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint` | `Untagged_immediate`


## Expressions

Expression _e_ ::=

* `Let` _bound_vars_ `=` _named_ `in` _e_  |
* `Let_symbol (` _scoping_rule_ `)` _bound_symbols_ `=` _static_const_ `in` _e_ |
* `Let_cont` _continuation_ `=` _let_cont_ `in` _e_  |
* `Apply` _call_kind_ _callee_ `(` _arg_* `)` _continuation_ _exn_continuation_ |
* `Apply_cont` _continuation_ `(` _arg_* `)` _trap_action_ |
* `Switch` _scrutinee_ _arms_ |
* `Invalid`

### `Let`

_bound_vars_ ::=

* `Singleton` _var_in_binding_pos_ |
* `Set_of_closures` (_name_mode_, _closure_vars_)

_name_mode_ ::= `Normal` | `Phantom` | `In_types`

_var_in_binding_pos_ ::= _name_mode_ _variable_

_named_ ::=

* `Simple` _simple_
* `Prim` _flambda_primitive_
* `Set_of_closures` _set_of_closures_

### `Let_symbol`

_scoping_rule_ ::= `Syntactic` | `Dominator`

_bound_symbols_ ::=

* `Singleton` _symbol_
* `Sets_of_closures` _code_and_set_of_closures_*

_static_const_ ::=

* `Block` _tag_ _mutable_or_immutable_ _field_of_block_* |
* `Sets_of_closures` _code_and_set_of_closures_* |
* `Boxed_float` [_B^64^_ | _variable_] |
* `Boxed_int32` [_B^32^_ | _variable_]  |
* `Boxed_int64` [_B^64^_ | _variable_]  |
* `Boxed_nativeint` [_targetint_ | _variable_]  |
* `Immutable_float_array` [_B^64^_ | _variable_]* |
* `Mutable_string` _string_ |
* `Immutable_string` _string_

### `Let_cont`


_continuation_handler_ ::= _kinded_parameter_* _e_

_continuation_handlers_ : [`(` _continuation_ `,` _continuation_handler_ `)`]*

_let_cont_ ::=

* `Non_recursive` _continuation_handler_ |
* `Recursive` _continuation_handlers_

### `Apply`

_call_kind_ ::=

* `Function` _function_call_ |
* `Method` _method_kind_ `of` _simple |_
* `C_call` _alloc_ _param_arity_ _return_arity_

_alloc_ ::= B

_flambda_arity_ ::= _flambda_kind_*

_param_arity_ ::= _flambda_arity_

_return_arity_ ::= _flambda_arity_

_function_call_ ::=

* `Direct` _code_id_ _closure_id_ _return_arity_ |
* `Indirect_unknown_arity` |
* `Indirect_known_arity` _param_arity_ _return_arity_

_callee_ ::= _simple_

_exn_continuation_ ::=  _continuation_ [`(`_simple_ `,` _flambda_kind_`)`]*

### `Apply_cont`

_raise_kind_option_ ::=
* `None` |
* `Some Regular` |
* `Some Reraise` |
* `Some No_trace`

_trap_action_ ::=

* `Push` _continuation_ |
* `Pop` _continuation_ _raise_kind_option_

### `Switch`

_scrutinee_ ::= _simple_

_arms_ ::= `(` _target_imm_ `, Apply_cont` _continuation_ `(` _arg_* `)` _trap_action_ `)`

_target_imm_ ::= _targetint_



# State

## Top-Level State

### Current Continuation

_body_ : Expression

### Environment

_env_: Environment

### Heap

_heap_: Ref -> Value


# TODO

* Ref
* Value
* Continuation
* ContinuationValue
** _env_: Environment
** _body_: Expression
* Environment =
** _continuations_ : Continuation -> ContinuationValue
** _return_cont_: Continuation
** _exn_cont_: Continuation


