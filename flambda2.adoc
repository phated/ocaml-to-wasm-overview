:toc:
:toclevels: 5


# Sketch of Flambda 2.0 Semantics

This is an attempt of creating a minimal, human-readable, mathematical representation of Flambda 2.0. I tried to choose names that most accurately describe what things are. Anything that is not absolutely required for the semantics is omitted.

Purpose: resolve misunderstandings and improve my understanding of how Flambda 2.0 works. May serve as a draft for a formal semantics or an interpreter of Flambda 2.0.

Dear reader, if you see something wrong, or you see something that can be removed, let me know.

# AST

## Basic Definitions

### Identifier

_id_ is a name that is used to refer to something in the environment.

### Simple

_simple_ ::= _id_

QUESTION: what does simple as an identifier refer to? Does this refer to variables whose value is known to be "simple"? How is this different from _variable_?

### Variable

_variable_ ::= _id_

_variable_ is an identifier that refers to a variable in the environment

### Continuation

_continuation_ :== _id_

_continuation_ is an identifier that refers to a continuation handler in the environment.

### Kind

_flambda_kind_ ::= `Value` | `Naked_number` | `Fabricated`

_naked_number_kind_ ::= `Naked_immediate` | `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_standard_int_ ::= `Tagged_immediate` | `Naked_immediate` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_standard_int_or_float_ ::= `Tagged_immediate` | `Naked_immediate` | `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_boxable_number_ ::= `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint` | `Untagged_immediate`


## Expressions

Expression _e_ ::=

* `Let` _bound_vars_ `=` _named_ `in` _e_  |
* `Let_symbol (` _scoping_rule_ `)` _bound_symbols_ `=` _static_const_ `in` _e_ |
* `Let_cont` _continuation_ `=` _let_cont_ `in` _e_  |
* `Apply` _call_kind_ _callee_ `(` _arg_* `)` _continuation_ _exn_continuation_ |
* `Apply_cont` _continuation_ `(` _arg_* `)` _trap_action_ |
* `Switch` _scrutinee_ _arms_ |
* `Invalid`

### `Let`

_bound_vars_ ::=

* `Singleton` _var_in_binding_pos_ |
* `Set_of_closures` (_name_mode_, _closure_vars_)

_name_mode_ ::= `Normal` | `Phantom` | `In_types`

_var_in_binding_pos_ ::= _name_mode_ _variable_

_named_ ::=

* `Simple` _simple_
* `Prim` _flambda_primitive_
* `Set_of_closures` _set_of_closures_

### `Let_symbol`

_scoping_rule_ ::= `Syntactic` | `Dominator`

_bound_symbols_ ::=

* `Singleton` _symbol_
* `Sets_of_closures` _code_and_set_of_closures_*

_static_const_ ::=

* `Block` _tag_ _mutable_or_immutable_ _field_of_block_* |
* `Sets_of_closures` _code_and_set_of_closures_* |
* `Boxed_float` [_B^64^_ | _variable_] |
* `Boxed_int32` [_B^32^_ | _variable_]  |
* `Boxed_int64` [_B^64^_ | _variable_]  |
* `Boxed_nativeint` [_targetint_ | _variable_]  |
* `Immutable_float_array` [_B^64^_ | _variable_]* |
* `Mutable_string` _string_ |
* `Immutable_string` _string_

_field_of_block_ ::=

* `Symbol` _symbol_ |
* `Tagged_immediate` _target_imm_ |
* `Dynamically_computed` _variable_

### `Let_cont`

_kinded_parameter_ ::= _variable_ : _flambda_kind_

_continuation_handler_ ::= `cont_handler` _kinded_parameter_* `.` _e_

_continuation_handlers_ : [_continuation_ `=>` _continuation_handler_]*

_let_cont_ ::=

* `Non_recursive` _continuation_handler_ |
* `Recursive` _continuation_handlers_

### `Apply`

_call_kind_ ::=

* `Function` _function_call_ |
* `Method` _method_kind_ `of` _simple |_
* `C_call` _alloc_ _param_arity_ _return_arity_

_method_kind_ ::= `Self` | `Public` | `Cached`

_alloc_ ::= B

_flambda_arity_ ::= _flambda_kind_*

_param_arity_ ::= _flambda_arity_

_return_arity_ ::= _flambda_arity_

_function_call_ ::=

* `Direct` _code_id_ _closure_id_ _return_arity_ |
* `Indirect_unknown_arity` |
* `Indirect_known_arity` _param_arity_ _return_arity_

_callee_ ::= _simple_

_exn_continuation_ ::= `exn_cont` _continuation_ `(` [_simple_ `=>` _flambda_kind_]* `)`

### `Apply_cont`

_raise_kind_option_ ::= `None` | `Some Regular` | `Some Reraise` | `Some No_trace`

_trap_action_ ::=

* `Push` _continuation_ |
* `Pop` _continuation_ _raise_kind_option_

### `Switch`

_scrutinee_ ::= _simple_

_arms_ ::= `(` _target_imm_ `, Apply_cont` _continuation_ `(` _arg_* `)` _trap_action_ `)`

_target_imm_ ::= _targetint_


# Module

_M_ = {

* _imported_symbols_ : Map(_symbol_ -> _flambda_kind_),
* _return_continuation_ : _continuation_,
* _exn_continuation_ : _continuation_,
* _body_ : _e_}

This is what the Flambda 2.0 unit looks like. I assume that this corresponds 1:1 to an OCaml Module.

I assume that _return_continuation_ and _exn_continuation_ act as placeholders for the continuations provided by whoever calls the module initialization function.

The _body_ of the module is the Flambda 2.0 expression that corresponds to all OCaml code of the module. So, this _body_ will likely define some global symbols and assign values to them.

At module initialization, the _body_ is run with an environment that contains all the necessary information about the symbols imported from other modules. That means, in order to initialize a module, all the modules that it depends on must be initialized beforehand.

# Program State

## Basic Definitions

### Reference

Ref is the set of abstract references to the heap. We do not care how exactly they look like. We assume the presence of a garbage collector that manages these references (whether this is one we implement, or one that the host environment will provide, we do not distinguish on, at this point).

### Function Reference

FuncRef is the set of abstract references to functions. The point of this is to refer to a function so that we can call it.

On x86-64 this specializes to: the memory address where the compiled code of the function lives.
On WASM, this specializes to: a `funcref` or an index into a global function table.

### (Heap) Value

Here is an attempt to describe what a heap value from the POV of Flambda 2.0 looks like, in the most general sense:

A Value _v_ is a sequence of _heap_field_.

_heap_field_ ::=

* `Targetint` _targetint_ |
* `FuncAddress` FuncRef |
* `Ref` Ref

I don't know if this is sufficient to describe all the different heap blocks there are.

I do have the suspicion, that it might make sense to make a more fine-grained model that takes into account the different tags that each come with specific assumptions about the block, I assume. In particular, how to model closure blocks and their Infix blocks in an abstract sense is unclear to me, at this point.

## Top-Level State

TODO

_env_: Environment

* Environment = {
** _continuations_ : _continuation_ -> _continuation_handler_,
** _return_cont_: _continuation_,
** _exn_cont_: _continuation_,
** _current_body_ : Expression }

_heap_: Ref -> Value


TODO

# Semantics

## Initial State

TODO

## Step function

TODO


