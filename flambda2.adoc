:toc:
:toclevels: 5


# Sketch of Flambda 2.0 Semantics

This is an attempt of creating a minimal, human-readable, mathematical representation of Flambda 2.0. I tried to choose names that most accurately describe what things are. Anything that is not absolutely required for the semantics is omitted.

Purpose: resolve misunderstandings and improve my understanding of how Flambda 2.0 works. May serve as a draft for a formal semantics or an interpreter of Flambda 2.0.

Dear reader, if you see something wrong, or you see something that can be removed, let me know.

# AST

## Basic Definitions

### Identifier

_id_ is a name that is used to refer to something in the environment.

### Simple

_simple_ ::= _id_

QUESTION: what does simple as an identifier refer to? Does this refer to variables whose value is known to be "simple"? How is this different from _variable_?

### Variable

_variable_ ::= _id_

_variable_ is an identifier that refers to a variable in the environment

### Continuation

_continuation_ :== _id_

_continuation_ is an identifier that refers to a continuation handler in the environment.

### Kind

_flambda_kind_ ::= `Value` | `Naked_number` | `Fabricated`

_naked_number_kind_ ::= `Naked_immediate` | `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_standard_int_ ::= `Tagged_immediate` | `Naked_immediate` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_standard_int_or_float_ ::= `Tagged_immediate` | `Naked_immediate` | `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint`

_flambda_kind_boxable_number_ ::= `Naked_float` | `Naked_int32` | `Naked_int64` | `Naked_nativeint` | `Untagged_immediate`


## Expressions

Expression _e_ ::=

* `Let` _bound_vars_ `=` _named_ `in` _e_  |
* `Let_symbol (` _scoping_rule_ `)` _bound_symbols_ `=` _static_const_ `in` _e_ |
* `Let_cont` _continuation_ `=` _let_cont_ `in` _e_  |
* `Apply` _call_kind_ _callee_ `(` _arg_* `)` _continuation_ _exn_continuation_ |
* `Apply_cont` _continuation_ `(` _arg_* `)` _trap_action_ |
* `Switch` _scrutinee_ _arms_ |
* `Invalid`

### `Let`

_bound_vars_ ::=

* `Singleton` _var_in_binding_pos_ |
* `Set_of_closures` (_name_mode_, _closure_vars_)

_name_mode_ ::= `Normal` | `Phantom` | `In_types`

_var_in_binding_pos_ ::= _name_mode_ _variable_

_named_ ::=

* `Simple` _simple_
* `Prim` _flambda_primitive_
* `Set_of_closures` _set_of_closures_

### `Let_symbol`

_scoping_rule_ ::= `Syntactic` | `Dominator`

_bound_symbols_ ::=

* `Singleton` _symbol_
* `Sets_of_closures` _code_and_set_of_closures_*

_static_const_ ::=

* `Block` _tag_ _mutable_or_immutable_ _field_of_block_* |
* `Sets_of_closures` _code_and_set_of_closures_* |
* `Boxed_float` [_B^64^_ | _variable_] |
* `Boxed_int32` [_B^32^_ | _variable_]  |
* `Boxed_int64` [_B^64^_ | _variable_]  |
* `Boxed_nativeint` [_targetint_ | _variable_]  |
* `Immutable_float_array` [_B^64^_ | _variable_]* |
* `Mutable_string` _string_ |
* `Immutable_string` _string_

### `Let_cont`

_kinded_parameter_ ::= _variable_ : _flambda_kind_

_continuation_handler_ ::= `cont_handler` (_kinded_parameter_*, _e_)

_continuation_handlers_ : [`(` _continuation_ `,` _continuation_handler_ `)`]*

_let_cont_ ::=

* `Non_recursive` _continuation_handler_ |
* `Recursive` _continuation_handlers_

### `Apply`

_call_kind_ ::=

* `Function` _function_call_ |
* `Method` _method_kind_ `of` _simple |_
* `C_call` _alloc_ _param_arity_ _return_arity_

_method_kind_ ::= `Self` | `Public` | `Cached`

_alloc_ ::= B

_flambda_arity_ ::= _flambda_kind_*

_param_arity_ ::= _flambda_arity_

_return_arity_ ::= _flambda_arity_

_function_call_ ::=

* `Direct` _code_id_ _closure_id_ _return_arity_ |
* `Indirect_unknown_arity` |
* `Indirect_known_arity` _param_arity_ _return_arity_

_callee_ ::= _simple_

_exn_continuation_ ::=  _continuation_ [`(` _simple_ `,` _flambda_kind_`)`]*

### `Apply_cont`

_raise_kind_option_ ::= `None` | `Some Regular` | `Some Reraise` | `Some No_trace`

_trap_action_ ::=

* `Push` _continuation_ |
* `Pop` _continuation_ _raise_kind_option_

### `Switch`

_scrutinee_ ::= _simple_

_arms_ ::= `(` _target_imm_ `, Apply_cont` _continuation_ `(` _arg_* `)` _trap_action_ `)`

_target_imm_ ::= _targetint_


# Module

A Flambda 2.0 module M consists of

* a mapping of _continuation_ identifiers to _continuation_handler_
+
P = _continuation_ -> _continuation_handler_


TODO: exported and imported symbols

TODO

# Program State

## Basic Definitions

### Reference

Ref is the set of abstract references to the heap. We do not care how exactly they look like.

### (Heap) Value

TODO

## Top-Level State

### Global Variables

TODO

### Environment

_env_: Environment

* Environment = {
** _continuations_ : _continuation_ -> ContinuationValue,
** _return_cont_: _continuation_,
** _exn_cont_: _continuation_,
** _current_body_ : Expression }

### Heap

_heap_: Ref -> Value

