# Ocaml to WASM - an Overview
:toc:
:toclevels: 5

This is a collection of links and ideas and notes on compiling OCaml to WASM.

## General Notes

From http://caml.inria.fr/pub/ml-archives/caml-list/2009/03/3a77bfcca0f90b763d127d1581d6a2f1.en.html (Xavier Leroy, 2009):
....
3- A language implementation like OCaml breaks down in four big parts:
        1- Front-end compiler
        2- Back-end compiler and code emitter
        3- Run-time system
        4- OS interface

[...]

6- Here is a schematic of the Caml compiler.  (Use a fixed-width font.)

             |
             | parsing and preprocessing
             v
          Parsetree (untyped AST)
             |
             | type inference and checking
             v
          Typedtree (type-annotated AST)
             |
             | pattern-matching compilation, elimination of modules, classes
             v
          Lambda
           /  \
          /    \ closure conversion, inlining, uncurrying,
         v      \  data representation strategy
      Bytecode   \
                  \
                 Cmm
                  |
                  | code generation
                  v
               Assembly code
....

## Paths to WASM

Direct::
* 1a) translate Lambda -> WASM
* 1b) translate Cmm -> WASM
* 1c) translate OCaml bytecode -> WASM
* 1d) run a bytecode interpreter for OCaml in WASM

Indirect::
* 2a) Cmm -> LLVM -> WASM
* 2b) OCaml bytecode -> LLVM -> WASM
* 2c) Ocaml -> machine code -> WASM

Runtime / Garbage collector::
* gc1) "Manual" garbage collection on the WASM `mem`, by maintaining a shadow stack
+
This is apparently what the https://docs.google.com/document/d/131vjr4DH6JFnb-blm_uRdaC0_Nv3OUwjEY5qVCxCup4/preview#heading=h.nrkaoiab5j18[WASM backend of the Go language] does.

* gc2) Use the https://github.com/WebAssembly/gc[WASM garbage collector], if/when it becomes available
+
The WASM garbage collector specification is still at a very early stage, and it is not clear how exactly it will work.

* gc3) Using `anyref` to allocate heap objects when https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md[Reference Types] become available.
+  
This means using the JavaScript garbage collector, which might or might not be very different from the upcoming WASM garbage collector.

## Direct Roads to WASM

### 1a) Lambda -> WASM

While there are currently no projects that translate OCaml's lambda IR to WASM, there are these:

* **[production-ready]** Bucklescript (Ocaml rawlambda) -> JavaScript: https://github.com/BuckleScript/bucklescript
+
This may or may not be helpful, I do not know. 
+
From https://github.com/BuckleScript/bucklescript/blob/master/site/docsource/Differences-from-js_of_ocaml.adoc:
+
"Js_of_ocaml focuses more on existing OCaml ecosystem(opam) while BuckleScriptâ€™s major goal is to target npm"
+
"Js_of_ocaml and BuckleScript have slightly different runtime encoding in several places, for example, BuckleScript encodes OCaml Array as JS Array while js_of_ocaml requires its index 0 to be of value 0."
+
Overview of the bucklescript compiler: https://github.com/BuckleScript/bucklescript/blob/master/site/docsource/Compiler-overview.adoc

* **[probably abandoned]** the Grain Language -> WASM https://github.com/grain-lang/grain
+
Even though the source language used here is not OCaml, there might be some interesting observations in here about compiling a functional language to WASM.
+
"Low-level IR, suitable for direct translation into WASM": https://github.com/grain-lang/grain/blob/master/src/codegen/mashtree.ml



### 1b) Cmm -> WASM

Starting from an already optimized version of the program is likely to result in a comparatively fast execution speed.

* **[abandoned]** https://github.com/rolph-recto/ocaml-wasm/tree/wasm/wasmcomp
+
"first working version: compiles arith exprs only", latest commit Jul 27, 2018

* **[WIP]** Ocaml Cmm -> WASM https://github.com/SanderSpies/ocaml/tree/manual_gc/asmcomp/wasm32
+
https://medium.com/@sanderspies/a-webassembly-backend-for-ocaml-b78e7eeea9d5
+
https://medium.com/@sanderspies/the-road-to-webassembly-gc-for-ocaml-bd44dc7f9a9d
+
Experiments on GC: https://github.com/SanderSpies/ocaml-wasm-gc-experimenting

* **[WIP]** Haskell Cmm -> WASM https://github.com/tweag/asterius
+
"we implement the cmm-to-wasm code generator as yet another native backend, and any non-Haskell logic of the runtime is hand-written WebAssembly code, which means we're simulating various rts interfaces to the degree that a significant portion of vanilla Haskell code becomes runnable." (https://www.tweag.io/posts/2018-05-29-hello-asterius.html[see here])
+
Garbage collection: https://github.com/tweag/asterius/issues/52

### 1c) OCaml bytecode -> WASM

I am not aware of any projects that attempt translating from OCaml bytecode to WASM. Please let me know if you are.

An advantage is that the bytecode interpreter hardly ever changes at all (it is said to still be quite similar to what is laid out in https://caml.inria.fr/pub/papers/xleroy-zinc.pdf[the original report on ZINC]).

There is no dependency on compiler internals, as we can work on the bytecode output of `ocamlc`.

In the past, translating bytecode has proven to be a successful and maintainable strategy for compiling OCaml to different languages:

* **[production-ready]** OCaml bytecode -> JavaScript: https://github.com/ocsigen/js_of_ocaml
+
https://www.irif.fr/~balat/publications/vouillon_balat-js_of_ocaml.pdf presents performance results from 2011: The code generated by `js_of_ocaml` running on the V8 JavaScript engine was faster than running the bytecode interpreter on the bytecode generated by `ocamlc`, and slower than the machine code generated by `ocamlopt`.
  Exceptions turned out to be very expensive.
+  
`js_of_ocaml` is being used in production systems, as far as I know, it is currently the best tool to compile OCaml to JavaScript.
+  
*Note:* It is unlikely, that exceptions will be an issue when compiling to WASM, since the exception mechanism in WASM is different from the one in JavaScript.

* **[inactive]** Ocaml bytecode -> C: https://github.com/bvaugon/ocamlcc
+
According to http://michel.mauny.net/data/papers/mauny-vaugon-ocamlcc-oud2012.pdf, performance in 2012 was better than running the bytecode interpreter, and worse than running the machine code generated by `ocamlopt`, which essentially was to be expected. However, this comes at the cost of having large executables, roughly up to twice the size of machine code in the considered examples.
+
I managed to compile this using an older version of the OCaml compiler.
+
I can compile trivial test programs to C.
+
Compiling that C code using Emscripten to WASM, I am stuck with this error on the JavaScript console:
+
....
exception thrown: RuntimeError: index out of bounds,_caml_page_table_modify@http://127.0.0.1:8000/output.js:45026:1
_caml_page_table_add@http://127.0.0.1:8000/output.js:44203:1
_caml_set_minor_heap_size@http://127.0.0.1:8000/output.js:89253:1
_caml_init_gc@http://127.0.0.1:8000/output.js:90849:1
_caml_main@http://127.0.0.1:8000/output.js:99291:1
_main@http://127.0.0.1:8000/output.js:110038:1
Module._main@http://127.0.0.1:8000/output.js:6717:10
callMain@http://127.0.0.1:8000/output.js:7005:15
doRun@http://127.0.0.1:8000/output.js:7064:23
run/<@http://127.0.0.1:8000/output.js:7075:7
....
  

### 1d) bytecode interpreter in WASM

* **[inactive]** https://github.com/sebmarkbage/ocamlrun-wasm
+
sebmarkbage compiled the OCaml bytecode interpreter, as well as the GC to WASM using emscripten. https://github.com/sebmarkbage/ocamlrun-wasm/commit/473580d7d2955ce254c2d0263383f7e251f6e497[Latest commit Mar 6, 2017]
+
I tried to compile this, but am stuck at the problem described in https://github.com/sebmarkbage/ocamlrun-wasm/issues/1[Issue 1]

## Indirect Roads to WASM

If there was a compiler from OCaml to LLVM, it would immediately enable compilation to WASM.

* **[discussion]** http://caml.inria.fr/pub/ml-archives/caml-list/2009/03/3a77bfcca0f90b763d127d1581d6a2f1.en.html

* **[discussion]** https://discuss.ocaml.org/t/llvm-backend-for-ocaml/1132/5

### 2a) Cmm -> LLVM

* **[abandoned]** Cmm -> LLVM https://github.com/whitequark/ocaml-llvm-ng/blob/master/lib/llvmcomp.ml

### 2b) OCaml bytecode -> LLVM

* **[abandoned]** OCaml bytecode -> LLVM https://github.com/raph-amiard/CamllVM
+
"TLDR : In the end it is just not worth it to optimize this project for performance. A better approach would be to start from scratch and do a real OCaml -> LLVM compiler for ocamlopt, that would be able to use the full AST with type information." https://news.ycombinator.com/item?id=4798320

### 2c) machine code -> WASM

For compiling machine code to WASM, there apparently do not currently exist any solutions.

It may be that it is commonly thought (and, possibly, actually true) that machine code is already too highly specialized to the specific architecture it runs on, so that "reverse-compiling" to WASM is unlikely to give good results.

I do not know if this is the case for all architectures.

If there was an architecture whose machine code can be translated to WASM in a reasonably efficient fashion, and it turns out that OCaml already compiles to this architecture, this could be interesting.

If successful, this would not only enable compiling OCaml to WASM, but could be helpful for getting many other languages to compile to WASM as well.


# Useful Libraries

* wasm - https://opam.ocaml.org/packages/wasm/
+
"An OCaml library to read and write Web Assembly (wasm) files and manipulate their AST."
