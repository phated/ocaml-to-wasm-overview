# Ocaml to WASM - an Overview
:toc:
:toclevels: 5

This is a collection of links and ideas and notes on compiling OCaml to WASM.

## General Notes

From http://caml.inria.fr/pub/ml-archives/caml-list/2009/03/3a77bfcca0f90b763d127d1581d6a2f1.en.html (Xavier Leroy, 2009):
....
3- A language implementation like OCaml breaks down in four big parts:
        1- Front-end compiler
        2- Back-end compiler and code emitter
        3- Run-time system
        4- OS interface

[...]

6- Here is a schematic of the Caml compiler.  (Use a fixed-width font.)

             |
             | parsing and preprocessing
             v
          Parsetree (untyped AST)
             |
             | type inference and checking
             v
          Typedtree (type-annotated AST)
             |
             | pattern-matching compilation, elimination of modules, classes
             v
          Lambda
           /  \
          /    \ closure conversion, inlining, uncurrying,
         v      \  data representation strategy
      Bytecode   \
                  \
                 Cmm
                  |
                  | code generation
                  v
               Assembly code
....


A more recent high-level view of the compilation pipeline (from https://ocamllabs.slack.com/archives/C0JCHGE78/p1568626615023800, Sep 16, 2019):
....
 Source code
   |
   | parsing
   v
 Parsetree
   |
   | typing
   v
 Typedtree
   |
   | desugar pattern matching, modules, objects, etc; erase types,
   | make explicit memory layout in terms of blocks and values
   |
   v
 Lambda (higher order lambda calculus based IR)
   |
   | make closure construction and usage explicit
   | perform inlining
   |
   v
 Clambda (like Lambda but with explicit closures, direct/indirect calls)
   |
   | make block/value manipulation explicit
   | make allocation explicit
   |
   v
  Cmm (tree-structured, explicit memory manipulation, C calls, etc)
   |
   | perform instruction selection,
   | sequentialization into basic blocks,
   | assignment of pseudo-registers
   |
   v
  Mach (block structured IR)
   |
   | liveness, register allocation, dead code elimination
   | are Mach -> Mach transformations
   |
   v
 Linear (linear sequence of abstract assembly instructions, explicit register assignments)
   |
   | this step is heavily backend-dependent, implemented in `emit.mlp`
   |
   v
 Textual assembly code
....

## Runtime / Garbage Collection

Both OCaml bytecode and OCaml native code needs a runtime accompanying the executable, in order to run the compiled program.

* gc1) "Manual" garbage collection on the WASM `mem`, by maintaining a shadow stack
+
This is apparently what the https://docs.google.com/document/d/131vjr4DH6JFnb-blm_uRdaC0_Nv3OUwjEY5qVCxCup4/preview#heading=h.nrkaoiab5j18[WASM backend of the Go language] does.

* gc2) Use the https://github.com/WebAssembly/gc[WASM garbage collector], if/when it becomes available
+
The WASM garbage collector specification is still at a very early stage, and it is not clear how exactly it will work.

* gc3) Using `anyref` to allocate heap objects on "the JavaScript side of the world" when https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md[Reference Types] become available.
+  
This means using the JavaScript garbage collector, which might or might not be very different from the upcoming WASM garbage collector.


## Paths to WASM

Direct::
* 1a) translate Lambda -> WASM
* 1b) translate Cmm -> WASM
* 1c) translate OCaml bytecode -> WASM
* 1d) run a bytecode interpreter for OCaml in WASM

Indirect::
* 2a) Cmm -> LLVM -> WASM
* 2b) OCaml bytecode -> LLVM -> WASM
* 2c) Ocaml -> machine code -> WASM

## Direct Roads to WASM

### 1a) Lambda -> WASM

While there are currently no projects that translate OCaml's lambda IR to WASM, there are these:

* **[production-ready]** Bucklescript (Ocaml rawlambda) -> JavaScript: https://github.com/BuckleScript/bucklescript
+
This may or may not be helpful, I do not know. 
+
From https://github.com/BuckleScript/bucklescript/blob/00ad78cbcfd1132d3a5931fe760706de35e480f6/site/docsource/Differences-from-js_of_ocaml.adoc:
+
"Js_of_ocaml focuses more on existing OCaml ecosystem(opam) while BuckleScriptâ€™s major goal is to target npm"
+
"Js_of_ocaml and BuckleScript have slightly different runtime encoding in several places, for example, BuckleScript encodes OCaml Array as JS Array while js_of_ocaml requires its index 0 to be of value 0."
+
Overview of the bucklescript compiler: https://github.com/BuckleScript/bucklescript/blob/00ad78cbcfd1132d3a5931fe760706de35e480f6/site/docsource/Compiler-overview.adoc

* **[probably abandoned]** the Grain Language -> WASM https://github.com/grain-lang/grain
+
Even though the source language used here is not OCaml, there might be some interesting observations in here about compiling a functional language to WASM.
+
"Low-level IR, suitable for direct translation into WASM": https://github.com/grain-lang/grain/blob/78dc08b2887226cf0b9f93357ca6fd689fcd1405/src/codegen/mashtree.ml



### 1b) Cmm -> WASM

Starting from an already optimized version of the program is likely to result in a comparatively fast execution speed.

* **[abandoned]** https://github.com/rolph-recto/ocaml-wasm/tree/wasm/wasmcomp
+
"first working version: compiles arith exprs only", latest commit Jul 27, 2018

* **[WIP]** Ocaml Cmm -> WASM https://github.com/SanderSpies/ocaml/tree/manual_gc/asmcomp/wasm32
+
https://medium.com/@sanderspies/a-webassembly-backend-for-ocaml-b78e7eeea9d5
+
https://medium.com/@sanderspies/the-road-to-webassembly-gc-for-ocaml-bd44dc7f9a9d
+
Experiments on GC: https://github.com/SanderSpies/ocaml-wasm-gc-experimenting
+
I seems that this is based on the official WASM specification `ast.ml`, but copied and modified to use a symbol type, instead of string for function and variable identifiers: https://github.com/SanderSpies/ocaml/commit/60a0d4218b34a0ace29a39e925c12cb5a76a3c55
+
It also looks like there is a few (commmented-out) lines added for https://github.com/WebAssembly/exception-handling/blob/master/proposals/Exceptions.md[the upcoming WASM exception-handling feature].

* **[WIP]** Haskell Cmm -> WASM https://github.com/tweag/asterius
+
"we implement the cmm-to-wasm code generator as yet another native backend, and any non-Haskell logic of the runtime is hand-written WebAssembly code, which means we're simulating various rts interfaces to the degree that a significant portion of vanilla Haskell code becomes runnable." (https://www.tweag.io/posts/2018-05-29-hello-asterius.html[see here])
+
Garbage collection: https://github.com/tweag/asterius/issues/52

### 1c) OCaml bytecode -> WASM

I am not aware of any projects that attempt translating from OCaml bytecode to WASM. Please let me know if you are.

An advantage is that the bytecode interpreter hardly ever changes at all (it is said to still be quite similar to what is laid out in https://caml.inria.fr/pub/papers/xleroy-zinc.pdf[the original report on ZINC]).

There is no dependency on compiler internals, as we can work on the bytecode output of `ocamlc`.

In the past, translating bytecode has proven to be a successful and maintainable strategy for compiling OCaml to different languages:

* **[production-ready]** OCaml bytecode -> JavaScript: https://github.com/ocsigen/js_of_ocaml
+
https://www.irif.fr/~balat/publications/vouillon_balat-js_of_ocaml.pdf presents performance results from 2011: The code generated by `js_of_ocaml` running on the V8 JavaScript engine was faster than running the bytecode interpreter on the bytecode generated by `ocamlc`, and slower than the machine code generated by `ocamlopt`.
  Exceptions turned out to be very expensive.
+  
`js_of_ocaml` is being used in production systems, as far as I know, it is currently the best tool to compile OCaml to JavaScript.
+
OCaml values are allocated on the JavaScript heap (**gc3**), thus, the calls to the garbage collector are just stubs: https://github.com/ocsigen/js_of_ocaml/blob/e7a34b8e0697a34b235ff121132c72121c16798d/runtime/gc.js
+
*Note:* It is unlikely, that exceptions will be an issue when compiling to WASM, since the exception mechanism in WASM will be different from the one in JavaScript.


* **[inactive]** Ocaml bytecode -> C: https://github.com/bvaugon/ocamlcc
+
According to http://michel.mauny.net/data/papers/mauny-vaugon-ocamlcc-oud2012.pdf, performance in 2012 was better than running the bytecode interpreter, and worse than running the machine code generated by `ocamlopt`, which essentially was to be expected. However, this comes at the cost of having large executables, roughly up to twice the size of machine code in the considered examples.
+
I managed to compile this using an older version of the OCaml compiler.
+
I can compile trivial test programs to C.
+
Compiling that C code using Emscripten to WASM, I am stuck with this error on the JavaScript console:
+
....
exception thrown: RuntimeError: index out of bounds,_caml_page_table_modify@http://127.0.0.1:8000/output.js:45026:1
_caml_page_table_add@http://127.0.0.1:8000/output.js:44203:1
_caml_set_minor_heap_size@http://127.0.0.1:8000/output.js:89253:1
_caml_init_gc@http://127.0.0.1:8000/output.js:90849:1
_caml_main@http://127.0.0.1:8000/output.js:99291:1
_main@http://127.0.0.1:8000/output.js:110038:1
Module._main@http://127.0.0.1:8000/output.js:6717:10
callMain@http://127.0.0.1:8000/output.js:7005:15
doRun@http://127.0.0.1:8000/output.js:7064:23
run/<@http://127.0.0.1:8000/output.js:7075:7
....
+
I'm having trouble debugging this because I don't have source maps for the C files where the `\_caml_`-functions come from. The reason seems to be that the files aren't actually included, only the headers. So I need to figure out what parameters to provide to emcc. In order to do that, I need to figure out what parameters ocamlcc uses to compile the code with gcc.
+
I was able to get the parameters from ocamlcc by using the -verbose option, now the error is this:
+
....
shared:ERROR: emcc: cannot find library "curses"
....
+
While I could continue here, I think that this is a dead end due to the large code size.

### 1d) bytecode interpreter in WASM

* **[inactive]** https://github.com/sebmarkbage/ocamlrun-wasm
+
sebmarkbage compiled the OCaml bytecode interpreter, as well as the GC to WASM using emscripten. https://github.com/sebmarkbage/ocamlrun-wasm/commit/473580d7d2955ce254c2d0263383f7e251f6e497[Latest commit Mar 6, 2017]
+
I tried to compile this, but am stuck at the problem described in https://github.com/sebmarkbage/ocamlrun-wasm/issues/1[Issue 1]


## Indirect Roads to WASM

If there was a compiler from OCaml to LLVM, it would immediately enable compilation to WASM.

* **[discussion]** http://caml.inria.fr/pub/ml-archives/caml-list/2009/03/3a77bfcca0f90b763d127d1581d6a2f1.en.html

* **[discussion]** https://discuss.ocaml.org/t/llvm-backend-for-ocaml/1132/5

### 2a) Cmm -> LLVM

* **[abandoned]** Cmm -> LLVM https://github.com/whitequark/ocaml-llvm-ng/blob/master/lib/llvmcomp.ml

### 2b) OCaml bytecode -> LLVM

* **[abandoned]** OCaml bytecode -> LLVM https://github.com/raph-amiard/CamllVM
+
"TLDR : In the end it is just not worth it to optimize this project for performance. A better approach would be to start from scratch and do a real OCaml -> LLVM compiler for ocamlopt, that would be able to use the full AST with type information." https://news.ycombinator.com/item?id=4798320

### 2c) machine code -> WASM

For compiling machine code to WASM, there apparently do not currently exist any solutions.

One would need to apply some kind of algorithm that transforms the control flow from a program-counter-based representation to the labeled continuations that can be seen in WASM, just like Emscripten's "Relooper" algorithm does for LLVM.

If there is an architecture whose machine code can be translated to WASM in a reasonably efficient fashion, and it turns out that OCaml already compiles to this architecture, this could be interesting.

If successful, this could, in the long run, help getting many other languages to compile to WASM as well.

# Useful Things

* wasm - https://opam.ocaml.org/packages/wasm/
+
"An OCaml library to read and write Web Assembly (wasm) files and manipulate their AST."

* "Malfunctional Programming" (the author implemented an interpreter for lambda, which should be similar to one for Cmm) https://www.cl.cam.ac.uk/~sd601/papers/malfunction.pdf

* "Caml Virtual Machine - Instruction set Document version: 1.4" http://cadmium.x9c.fr/distrib/caml-instructions.pdf
+
description of compiler version 3.11.2's bytecode

* How to write programs that never allocate http://www.ocamlpro.com/2016/04/01/asm-ocaml/

* loading `Cmm` in the interpreter:
+
....
#load "compiler-libs/ocamlcommon.cma";;
#load "compiler-libs/ocamloptcomp.cma";;
#require "compiler-libs.optcomp";;
#show_module Cmm;;
....

* A Scheme to WASM compiler - https://github.com/google/schism

* WASM tail calls proposal - https://github.com/WebAssembly/tail-call/blob/125201ced9a0f158553d08d8a20b7152f3057367/proposals/tail-call/Overview.md

* CakeML a verified ML compiler - https://cakeml.org/
+
Contains formal semantics for different intermediate representations in their compilation pipeline.
+
"A New Verified Compiler Backend for CakeML" (presentation of the overall structure and the intermediate languages of the CakeML compiler) https://cakeml.org/icfp16.pdf

* How to Represent Elm functions in Web Assembly https://dev.to/briancarroll/elm-functions-in-webassembly-50ak

* Solving the structured control flow problem (Improving on the Relooper algorithm) https://medium.com/leaningtech/solving-the-structured-control-flow-problem-once-and-for-all-5123117b1ee2

* How to explore Cmm semantics by looking at the generated x86 code (useful if you feel comfortable with assembly code):
+
....
ocamlopt test2.ml -S -inline 0 -nodynlink
ocamlopt test2.ml -dcmm
....
+
One can then look at the Cmm and the generated `test2.s` side-by-side.
+
When compiling on an x86-64 Intel machine using Debian, one can look at the runtime functions in https://github.com/ocaml/ocaml/blob/5ad64306d36755b600f2556805effb73627508c8/runtime/amd64.S.

* Talk on Rust, WebAssembly and JavaScript by Ashley Williams https://www.infoq.com/presentations/rust-webassembly-javascript/?utm_source=youtube&utm_medium=link&utm_campaign=qcontalks

